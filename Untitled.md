Voici une synthèse des informations concernant Elasticsearch, basée sur les documents fournis :\n\n**Architecture et déploiement :**\n\n* Le projet utilise Elasticsearch déployé sur Kubernetes (K8S).\n* L'architecture prévoit un cluster sur 4 noeuds (3 masters + 1 cold).\n* Les ressources Kubernetes allouées à chaque noeud master sont :\n * CPU : 500m\n * RAM : 2Gi\n* Le stockage est actuellement sur un volume persistant NFS.\n* Il est envisagé d'utiliser un cluster Elasticsearch mutualisé.\n\n**Index utilisés pour le projet RAG :**\n\n* `inno24-small` et `inno24-large` : index standard avec champ `dense_vector` (1536 dimensions pour `inno24-small`, 3012 pour `inno24-large`).\n* `interactions` : index texte standard stockant les interactions utilisateurs.\n* `templates` : stockage des prompts.\n* `questions` : stockage des questions pré-répliquées.\n\n**Taille des index :**\n\n* `inno24-small` et `inno24-large` : environ 170 MB pour `inno24-large` (estimation : 1 Go pour `inno24-small`).\n* Les autres index sont considérés comme anecdotiques (interactions : 60 MB, au pire 1 Go/an).\n\n**Mappings des index :**\n\n* Les mappings sont fournis dans le fichier `mappings.json`.\n* Les mappings et les ILM (Index Lifecycle Management) sont distincts.\n* Les mappings définissent la structure du schéma.\n* Par défaut, Elasticsearch utilise une configuration par défaut si aucun mapping n'est défini.\n* Les types `text` et `keyword` sont utilisés. `text` est indexé pour la recherche, `keyword` est un mot indexé avant la recherche.\n* Le concept de Shard est utilisé.\n* Il est recommandé d'indexer en texte uniquement ce qui a un sens.\n* Un texte ne peut pas être agrégé.\n* Il est possible de mettre en place deux index : un avec un mapping défini et un autre libre.\n* La structure de recherche peut être basée sur les métadonnées et ElasticSearch Nested pour les données liées.\n* Il est nécessaire d'utiliser un type texte avec vector pour la recherche sémantique.\n* La taille maximale d'un champ keyword est de 256 caractères.\n\n**Stratégie d'indexation :**\n\n* Il est déconseillé d'utiliser l'opération `update` car Elasticsearch est conçu pour les données statiques.\n* Il est préférable d'utiliser un refresh complet, surtout en cas de faible volume de documents.\n* Actuellement, l'index est vidé au lieu d'être créé. Il est préférable de supprimer l'index si le template et les mappings sont présents.\n\n**Gestion des index (bonnes pratiques) :**\n\n* Il est recommandé d'utiliser un index séparé par domaine (namespaces).\n* Il est conseillé d'ajouter des métadonnées obligatoires à tous les documents (domain, audience, doc\_type, etc.).\n* Un vocabulaire contrôlé (mini-ontologie) peut être utilisé pour standardiser les labels et les alias.\n* La décision d'utiliser des index séparés pour des données différentes doit être prise en fonction des besoins.\n* La recherche vectorielle est plus consommatrice en RAM que la recherche textuelle.\n\n**Recherche sémantique vs. BM25 :**\n\n* La recherche sémantique KNN (K-Nearest Neighbors) est recommandée (à partir de Elasticsearch 8.12 ou supérieur) pour la recherche par similarité vectorielle.\n* BM25 couplé avec KNN est une solution éprouvée.\n\n**Cache :**\n\n* La gestion de cache est possible mais n'est pas implémentée actuellement.\n* Il existe trois types de caches : "page", "query" et "query/partition".\n\n**Impact de la recherche vectorielle :**\n\n* La recherche vectorielle est plus "lourde" en RAM, mais proportionnelle au volume de données.\n\n**Autres points :**\n\n* Il est possible d'utiliser des plugins Elasticsearch pour déporter les éléments RAG.\n* L'utilisation de PowerBI pour la visualisation n'est pas recommandée, Kibana est préférable.\n* La protection contre l'IA ouverte est un sujet à considérer.\n* La facturation de l'utilisation d'Elasticsearch doit être vérifiée.
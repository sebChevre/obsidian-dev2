Voici une synthèse des informations concernant Elasticsearch, basée sur les documents fournis :\n\n### Architecture\n\n* Le projet utilise Elasticsearch déployé sur K8S.\n* L'architecture prévoit l'utilisation d'un cluster mutualisé sur 4 noeuds (3 masters + 1 cold).\n* Il existe une architecture avec Elasticsearch mutualisé (voir image `gpt-jura-es-mut.drawio.png`).\n\n### Index\n\n* Les index utilisés pour le projet RAG sont :\n * `inno24-small`, `inno24-large`: index standard avec champ `dense_vector` (1536 pour small, 3012 pour large).\n * `interactions`: index texte standard stockant les interactions utilisateurs.\n * `templates`: stockage des prompts.\n * `questions`: stockage des questions pré-répliquées.\n* La taille des index est estimée :\n * `inno24-small` et `inno24-large`: actuellement ~900 documents, 170 MB (large), à prévoir ~5000 documents, 1GO.\n * Les autres index sont considérés comme anecdotiques (interactions actuellement 60MB, au pire 1Go/an).\n* Les mappings des index sont fournis dans le fichier `mappings.json`.\n\n### Bonnes pratiques et recommandations\n\n* **Gestion des index (cluster mutualisé):**\n * Index séparés, un index par environnement, avec une stratégie de nommage.\n * Définition des ILM (Index Lifecycle Management) pour la gestion du cycle de vie des données.\n * Templates à utiliser au niveau component et niveau index.\n * Dimensionnement : prévoir 20% de plus que le besoin de base (RAM), à confirmer avec FaWi.\n * Utiliser Kibana à la place de PowerBi pour la visualisation. Prévoir des espaces `inno24`.\n* **Stratégie d'indexation:**\n * Privilégier le refresh complet plutôt que l'update, car Elasticsearch est conçu pour des données statiques.\n * Vider l'index est à privilégier plutôt que de le créer.\n * Supprimer l'index est plus efficient si le template et les mappings sont présents.\n* **Mappings:**\n * Les mappings et ILM sont différents.\n * Les mappings définissent la structure/schema.\n * Par défaut, la configuration est décidée par Elasticsearch si aucun mapping n'est défini.\n * Utiliser `type text` pour l'indexation du texte.\n * Utiliser `type keyword` pour les mots (indexation avant la recherche).\n * Utiliser `Elasticsearch Nested` pour les données liées (ex: nom et prénom).\n * Pour la recherche sémantique, utiliser `type text` avec `dense_vector` et supprimer `type keyword`.\n * La taille maximale d'un `keyword` est de 256 caractères.\n* **Recherche sémantique vs BM25:**\n * Recommandé d'utiliser la recherche sémantique KNN (natif Elasticsearch, version 8.12+).\n * BM25 couplé avec KNN est un cas d'usage avéré.\n* **Index séparés pour des données différentes:**\n * La décision d'utiliser des index séparés dépend des besoins (isolation métier, thématique).\n * Une séparation "light" peut être envisagée avec des index différents mais utilisant le même template.\n * La recherche sur plusieurs index en même temps peut complexifier les choses.\n* **Impact de la recherche vectorielle:**\n * La recherche vectorielle est plus consommatrice en RAM que la recherche textuelle.\n * L'impact est proportionnel au volume de données.\n * À évaluer avec FaWi dans le contexte des log-events.\n* **Gestion de cache:**\n * Possible quand le besoin sera là (TB).\n * 3 types de caches : "page", "query", "query/partition".\n* **Architecture documentaire:**\n * Découpage par domaines (namespaces) avec un index par grand domaine et un index "référentiels partagés".\n * Ajout de métadonnées obligatoires (domain, audience, doc\_type, etc.) pour des filtres stricts.\n * Utilisation d'un vocabulaire contrôlé (labels canoniques + alias) pour assurer la cohérence.\n\n### Points à discuter\n\n* État de situation, évolutions, aspects budgets.\n* Environnements.\n* Plugin RAG Elasticsearch pour déporter les éléments RAG.\n* Varios.ia (protection contre l'IA ouverte).\n* Facturation (à voir avec Charline).